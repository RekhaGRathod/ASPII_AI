question,answer,score,sentiment
"So for today's question, you can assume that you work as a data scientist for an E commerce company and for this company they have a database containing these three tables here. So there's a transactions table, a product table and a users table. So the transactions, each of them are uniquely identified by an id. Each transaction is associated with a specific user ID and you also have the quantity, the time it was created and the product id. So the product ID of that table links to the ID in the products table. And for each product you also have the name and the price of the product product. And lastly, you have the users table where the ID column links back to the user ID in the transactions table and you have the name and the sex for each user. All right, so let's get started with our first question then. The first question today is can you write a query that reports the number of users, the number of transactions placed and the total order amount per month in the year 2020? For those of you who aren't already familiar with Exponent, Exponent helps you get your dream tech career with our online courses, expert coaching, peer to peer, mock interviewing, platform and inter database. Check it out@tryexponent.com.","Sounds great. If you don't mind, I'd like to ask some clarification questions about the expected output and also about the data before I start to talk about logic and start querying, if that's okay.",0.598,Positive
"Yeah, absolutely. Please go ahead.","So yeah, looking at the table structure, it looks like ID is primary key for all these tables, transaction products and users tables. And it looks like in the transactions table we have something called user ID and I'm assuming that is going to map to the ID in the users table. And same goes with the product ID here. And I'm also assuming every product that is in the transaction table is covered in the product table. The way there are no gaps between these two tables. Are these assumptions looking good or anything you would like to add?",0.8655,Positive
"Yeah, that all sounds right to me.","Cool. And in terms of expected output, as you outlined, this sounds like a monthly reporting where we'll be looking at number of users, number of transactions and also the total order amount. The way I think I'm going to be computing order amount is I see price column in the products table and I also see quantity in the transaction. So I'm actually assuming I can multiply these two to get the total order amount. For example, if a user is buying two product and the price is $10, the total order amount is going to be $20. So 2 times 10. Does that make sense?",0.6597,Positive
"Yeah, that totally makes sense.","Yeah. So first thing I'd like to do is usually explore the table to see what kind of data I have. It'll be interesting to actually note down all the data types that we have in this table. One thing I can tell right off of the bat is it looks like we don't have to use user stable. So that's because we're not going to be reporting on name or gender at the moment. So I'm going to be using the first two table transactions and the product table. So let me do a quick querying. It looks like these tables have data, so let me outline the logic. Now what I'm going to do is I'm going to group all stats by month and I'm going to get month from the created at, which looks like a date time here. And then I'm going to use distinct count on the user to get the user account. Because it is possible that a user could have done two orders, but when it comes to the monthly report, we would only count them once because that's one user. Cool. Yeah. Anything you would like to add on the logic? Otherwise I'll get started with the query.",0.9481,Positive
"No, I think that makes sense to me. Cool.",So I'm going to call this monthly reporting of KPIs.,0.0,Neutral
Right.,"So I am. I'm actually commenting on the logic first. So I'm calling this query a monthly reporting KPI. And what I'm doing is I'm pulling each row in the transaction and I'm assuming each row in the transactions table is an order. And then as I said before, I'm doing price times quantity to get the order amount in terms of year. I'm only looking at 2020. So what I'm doing is I'm using date part function, SQL function to actually get the year and making sure it's actually 2020. So yeah, in terms of the summary, the user ID is going to give me number of customers. Transaction table is going to give me number of orders and then order amount is nothing but price times quantity and I group everything by month. The way we will get this monthly report. I'm going to quickly run this and see what output we are going to get. The output here is is monthly name which is essentially pointing to the number of month in a year. And then we have number of customers, number of orders and order amount. So I think this is what you are looking for.",0.6183,Positive
"Okay, perfect. That sounds really great. Is there anything else that you would like to improve in this Query.","Yeah. So in terms of readability, one thing that I usually do in my big queries is I create something called cte. Common table expression, especially price, times quantity could be confusing for new users to read when they're reading the query. So for that, I may create cte. I don't think it will impact performance that much, but I still think that's a good way to write the query. The other thing I could do is I could order this by month the way it's in the right order. Fortunately, the table that is given to me is in the right order. So that's why we are seeing it's ordered correctly. But in some cases, let's say this table is huge and the dates are kind of all over the place. Ordering will give readability of the report.",0.8422,Positive
"Okay, perfect. All right. So I'm curious then, like, what if you were to actually modify the query so that you could search over, so you could do the same query but over like multiple years, what would you have to do? Change?","Yeah, that's actually a great question. So here I'm actually filtering down only to 2020. So if I were to expand this, I'll need to do a couple of changes. One, I need to take this filter out. That way I'm looking at the entire table. I'm not restricting any particular year. The other thing that I need to think about is this month name. Right now I'm actually outputting the number. So as we start to add more years, what happens is it is possible that we will have orders for January of last year and January of this year. In my report, if we run this initial query, the first query, it will all be clubbed into one. So what I will do is I'll basically change this to reflect month name. So those are two changes I think I need to be making. Does that make sense? Anything you'd like to add? Nope.",0.9177,Positive
"That looks good to me. Okay, so let's move on to the next question then. So the next question then is who actually ordered the most? Can you write a query that will output the name of that user who has the most orders?","Yeah, definitely. So now we need to use Users table. Let's say we want to output the name. So the name is actually in the users table. And so technically I can reuse, but I'm going to start from scratch here. It's cleaner. So I'm going to actually look at the users table, I'm going to join transactions table and Users table, and I'm going to use user ID from the transactions Table to connect with the ID in the users table.",0.7543,Positive
"Okay, cool.","So in terms of logic, let me outline the logic with you so as to make sure you and I are on the same page. So I'm going to join the transactions table as I said. I'm going to sort the output by number of order and then I can limit to one. The way I'm only going to get the top row. It looks like you only or you're interested in capturing the top user. So I'm going to use a limit function. That's okay. Yep. So let me start coding here. Okay. I'm doing inner join on transactions and users and I'm grouping this entire query by user ID and name. And here's where I'm getting the number of orders. So essentially every row in the transactions table is considered an order. And then I'm actually sorting this in the descending order. And one final thing I will do is limit to one. So now if I execute. Cool. It looks like Ruksha Jarvis is the person who ordered the most. And this person ordered four orders.",0.9678,Positive
"Okay, perfect. So I'm curious though, what if there happened to be more than one user who like has the most orders?","Yeah, that's a great question. Right now I'm using this limit function or limit condition to make the query simple. But let's say there are a couple of people who ordered most. In that case, I will start to use window function. There are window functions like row, number, rank. If I were to use those table and I can decide which one, what I'm going to do in terms of a tie scenario, do I want to output all the names or do I want to only output one name? Based on what I want to do, I can use either of these window functions.",0.8481,Positive
"Okay, yeah. And is there any sort of like trade offs between using the limit statement versus the window functions?","Yeah, in terms of limit it is actually I would say it's not scalable. So it works for this query because I know what the data is because I've seen the data in the first query. But as if we were to expand this to a bigger table, that's usually the case with companies. Then window function is more appropriate. We can actually do partition by different columns. We can play around with the sorting, we can play around with how we are going to rank with window function. So window function offer more functionality for both scalability also for large database.",0.8674,Positive
"Okay, yeah, that makes a lot of sense. Okay, so I think this is a fantastic place to pause. You did a really great job on this and I'd be really curious to hear from you. What do you think went well and what do you think you would change?","Yeah, so I think the queries themselves are great. I could have done a little bit of optimization if I had more time. I could have used a CTE and maybe thought about performance as a factor if we are going to scale this query. But in terms of the queries themselves, I feel confident that it answered the questions that you had asked. So yeah, I feel it went really well.",0.9376,Positive
"Yeah, I totally agree with a lot of those points actually. I really in particular like that you were very careful about asking clarifying questions and verifying that your assumptions were correct before plunging into answering the questions. And I like the structure that you had of writing in comments, first of all, like what the logic for each sub part of the query that you're going to write was going to be. So that major query is really clear, especially for these queries that are longer and more complex. I think that's really helpful. And I really like that you were careful about the details too, like using distinct count to make sure that you didn't end up with duplicate rows. Yeah. And as for what might be improved, I do agree, like it might have been interesting to hear about some optimizations. So one thing that might be interesting to talk about is what if you were to run these queries? What if these are queries that you needed to run repeatedly all the time to generate automatically updating reports or something like that? Are there any optimizations that you can make to the actual tables themselves to optimize for these queries?","Yeah, so indexing is a common thing that we use in database to make queries faster. So what I would do if I were to design these tables is figure out what are primary keys, what are some other foreign keys and then I'll figure out how do we index these table. For example, in this database for all these three tables, it looks like the ID table is a primary key. And then there is also product ID which we use to join with other table. So there I would create an index. By creating index, this will actually run much faster and the queries will actually scale.",0.8578,Positive
"Yeah, that's exactly what I was thinking. Could you tell me a little bit more about why indexing makes these queries more efficient?","Yeah, so the way indexing is going to work in the back end is it's going to help the SQL engine to actually pick the right data in a short time frame. So let's say we are actually joining these two user IDs then what? So let's say the user ID is one and it will basically look for one in both these tables. If we index SQL engine knows exactly where to go and grab that data because it knows the ordering is going to be in either ascending or descending. So it can basically go either start at the top or at the bottom and scan for where it's going to get the one. So by indexing, we're actually making this scanning process quicker basically.",0.6908,Positive
"Yeah, it's kind of like it created a hash map from of the index values to the rows in the table itself, right?","Yeah, exactly. Yep, that's right.",0.5267,Positive
